#!/usr/bin/env ruby

require 'byebug'
require 'ostruct'
require 'drb/drb'
require 'rspec'
require 'forwardable'

$queue = []

DRB_URI="druby://localhost:8787"

class DrbExampleGroup
  def initialize(group)
    @group = group
  end

  def method_missing(m, *args)
    @group.send(m, *args)
  end

  def respond_to?(m, *args)
    super || @group.respond_to?(m, *args)
  end

  def run(reporter)
    puts "Queueing #{@group}"
    $queue << [self, reporter]
  end

=begin
  def self.children
  p :here
    super.map { |g| DrbExampleGroup.new(g) }
  end
=end
end

class DrbRunner < RSpec::Core::Runner
  def run_specs(example_groups)
    super(example_groups.map { |g| DrbExampleGroup.new(g) })
  end
end

class Controller
  def get_example
    example_group, reporter = $queue.shift
    if example_group.nil?
      return nil
    end
    m = example_group.metadata
    id = OpenStruct.new(
      file_path: m[:file_path],
      scoped_id: m[:scoped_id],
    )

    id
  end
end

class SlaveRunner
  def initialize
    runner.setup(STDOUT, STDERR)
  end

  def run(spec)
    group = runner.world.example_groups.detect do |g|
      g.metadata[:file_path] == spec[:file_path] &&
      g.metadata[:scoped_id] == spec[:scoped_id]
    end
    runner.run_specs([group]).tap do
      #persist_example_statuses
    end
  end

  private def runner
    @runner ||= begin
      options = RSpec::Core::ConfigurationOptions.new(ARGV)
      options.options[:formatters] = [['SlaveFormatter']]
      byebug
      RSpec::Core::Runner.new(options)
    end
  end
end

class SlaveFormatter
  RSpec::Core::Formatters.register self,
    :start,
    :example_group_started,
    :example_started,
    :example_passed,
    :example_failed,
    :example_pending,
    :message,
    :stop,
    :start_dump,
    :dump_pending,
    :dump_failures,
    :dump_summary,
    :seed,
    :close

  def initialize(output)
  end

  def start(notification)
    p notification
  end

  def stop(notification)
    p notification
  end

  def dump_summary(notification)
    p notification
  end

  def method_missing(m, args)
    p m
  end
end

runners = []
pipes = []
concurrency = 1
1.upto(concurrency) do |i|
  rd, wr = IO.pipe
  if pid = fork
    # parent
    rd.close
    pipes << wr
    runners << pid
  else
    # child
    wr.close
    rd.read(1)

    DRb.start_service
    controller = DRbObject.new_with_uri(DRB_URI)

    runner = SlaveRunner.new

    while spec = controller.get_example
      runner.run(spec)
      #example.run(reporter)
    end

    begin
      rd.read_nonblock(1)
    rescue EOFError
      rd.close
    rescue Errno::EWOULDBLOCK, Errno::EAGAIN, Errno::EINTR
    #puts "waiting in #{$$}"
      sleep 0.5
      retry
    end
    Process.exec('true')
  end
end

front_object = Controller.new
DRb.start_service(DRB_URI, front_object)

p DrbRunner.run(['spec'])

    pipes.each do |pipe|
      pipe.write('s')
    end

    pipes.each do |pipe|
      pipe.close
    end
    runners.each do |pid|
      begin
      #p "waiting for #{pid}"
        Process.wait(pid)
      rescue Errno::ECHILD
      end
    end

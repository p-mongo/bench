#!/usr/bin/env ruby

$: << File.join(File.dirname(__FILE__), '..', 'lib')

require 'psr'
require 'byebug'
require 'ostruct'
require 'drb/drb'
require 'rspec'
require 'forwardable'

#Psr.logger.level = Logger::DEBUG

$queue = []

DRB_URI="druby://localhost:8787"

class DrbExampleGroup
  def initialize(group)
    @group = group
  end

  def method_missing(m, *args)
    @group.send(m, *args)
  end

  def respond_to?(m, *args)
    super || @group.respond_to?(m, *args)
  end

  def run(reporter)
    puts "Queueing #{@group}"
    $queue << [self, reporter]
  end

=begin
  def self.children
  p :here
    super.map { |g| DrbExampleGroup.new(g) }
  end
=end
end

class DrbRunner < RSpec::Core::Runner
  def run_specs(example_groups)
    super(example_groups.map { |g| DrbExampleGroup.new(g) })
  end
end

class Controller
  def initialize(example_count:)
    @example_count = example_count
  end

  attr_reader :example_count

  def get_example
    example_group, reporter = $queue.shift
    if example_group.nil?
      return nil
    end
    m = example_group.metadata
    id = OpenStruct.new(
      file_path: m[:file_path],
      scoped_id: m[:scoped_id],
    )

    id
  end

  def example_passed(spec, execution_result)
  #return
    example = find_example(spec)
    # Can write to example here
    example.metadata[:execution_result] = execution_result
    status = execution_result.status
    m = "example_#{status}"
    #RSpec.configuration.reporter.report(1) do |reporter|
      reporter.send(m, example)
    #end
    #byebug
    #p args
  end

  def find_example(spec)
    example = all_examples.detect do |example|
      example.metadata[:file_path] == spec[:file_path] &&
      example.metadata[:scoped_id] == spec[:scoped_id]
    end
    unless example
    byebug
      raise "Not found: #{spec[:file_path]}[#{spec[:scoped_id]}]"
    end
    example
  end

  def run
  #p "total #{@example_count}"
    @start_time = Time.now
    reporter.report(@example_count) do
      yield
    end

  end

  def reporter
    @reporter ||= RSpec.configuration.reporter
  end

  def all_examples
    @all_examples ||= begin
      groups = [] + RSpec.world.example_groups
      examples = []
      until groups.empty?
        new_groups = []
        groups.each do |group|
          examples += group.examples
          new_groups += group.children
        end
        groups = new_groups
      end
      examples
    end
  end

  def dump_summary
    notification = RSpec::Core::Notifications::SummaryNotification.new(
      @start_time ? Time.now-@start_time : 0,
      all_examples,
      all_examples.select { |e| e.execution_result.status == :failed },
      all_examples.select { |e| e.execution_result.status == :pending },
      -1,
      123,
    )
    #p notification
    RSpec.configuration.formatters.first.dump_summary(notification)
  end
end

class MasterRunner
  def initialize
    runner.setup(STDOUT, STDERR)
  end

  private def runner
    @runner ||= begin
      options = RSpec::Core::ConfigurationOptions.new(ARGV)
      RSpec::Core::Runner.new(options)
    end
  end

end

class SlaveRunner
  def initialize
    runner.setup(STDOUT, STDERR)
  end

  def run(spec)
    group = runner.world.example_groups.detect do |g|
      g.metadata[:file_path] == spec[:file_path] &&
      g.metadata[:scoped_id] == spec[:scoped_id]
    end
    runner.run_specs([group]).tap do
      #persist_example_statuses
    end
  end

  private def runner
    @runner ||= begin
      options = RSpec::Core::ConfigurationOptions.new(ARGV)
      options.options[:formatters] = [['SlaveFormatter']]
      #byebug
      RSpec::Core::Runner.new(options)
    end
  end
end

class SlaveFormatter
  RSpec::Core::Formatters.register self,
    :start,
    :example_group_started,
    :example_started,
    :example_passed,
    :example_failed,
    :example_pending,
    :message,
    :stop,
    :start_dump,
    :dump_pending,
    :dump_failures,
    :dump_summary,
    :seed,
    :close

  def initialize(output)
  end

  def start(notification)
    #p notification
  end

  def stop(notification)
    #p notification
  end

  def dump_summary(notification)
    #byebug
  end

  def method_missing(m, args)
    #p m
  end

  def example_started(notification)
  end

  def example_passed(notification)
    example_notification(notification)
  end

  def example_notification(notification)
    spec = {
      file_path: notification.example.metadata[:file_path],
      scoped_id: notification.example.metadata[:scoped_id],
    }
    #byebug
    #p :a
    $controller.example_passed(spec, notification.example.execution_result)
    #b :b
    #1
  end

  def example_failed(notification)
    example_notification(notification)
  end

  def example_pending(notification)
    example_notification(notification)
  end
end

files = if ARGV.length > 0
  ARGV
else
  ['spec']
end
RSpec.configuration.files_or_directories_to_run = files

supervisor = Psr::Supervisor.new(concurrency: 8)
supervisor.run
exit 4

rd, wr = IO.pipe
if pid = fork
  # parent
  wr.close
  Process.wait(pid)

  example_count = rd.read.to_i
  rd.close
else
  # child
  rd.close
  RSpec.configuration.load_spec_files
  if RSpec.configuration.reporter.send(:instance_variable_get,'@non_example_exception_count') > 0
    exec('false')
  end

  byebug
  wr << Controller.new(example_count: 0).all_examples.count.to_s
  wr.close
  exec('true')
end

runners = []
pipes = []
concurrency = 4
1.upto(concurrency) do |i|
  rd, wr = IO.pipe
  if pid = fork
    # parent
    rd.close
    pipes << wr
    runners << pid
  else
    # child
    wr.close
    rd.read(1)

    DRb.start_service
    $controller = DRbObject.new_with_uri(DRB_URI)

    runner = SlaveRunner.new

    while spec = $controller.get_example
      runner.run(spec)
      #example.run(reporter)
    end

    begin
      rd.read_nonblock(1)
    rescue EOFError
      rd.close
    rescue Errno::EWOULDBLOCK, Errno::EAGAIN, Errno::EINTR
    #puts "waiting in #{$$}"
      sleep 0.5
      retry
    end
    Process.exec('true')
  end
end

controller = Controller.new(example_count: example_count)
DRb.start_service(DRB_URI, controller)

#MasterRunner.new
controller.run do
  DrbRunner.run(['spec'])
end

    pipes.each do |pipe|
      pipe.write('s')
    end

    pipes.each do |pipe|
      pipe.close
    end
    runners.each do |pid|
      begin
      #p "waiting for #{pid}"
        Process.wait(pid)
      rescue Errno::ECHILD
      end
    end

controller.dump_summary
